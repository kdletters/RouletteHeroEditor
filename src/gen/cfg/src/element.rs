
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ERaceType {
    None = 0,
    Item = 1,
    Cat = 2,
    Dog = 3,
    Bird = 4,
    Bug = 5,
    Fish = 6,
    Dragon = 7,
    Snake = 8,
    Hoofed = 9,
    Lizard = 10,
    Rodents = 11,
    Molluscs = 12,
    Furry = 13,
    Mod1 = 14,
    Mod2 = 15,
    Mod3 = 16,
    Mod4 = 17,
    Mod5 = 18,
    Mod6 = 19,
    Mod7 = 20,
    Mod8 = 21,
}

impl From<i32> for ERaceType {
    fn from(value: i32) -> Self {
        match value {
            0 => ERaceType::None,
            1 => ERaceType::Item,
            2 => ERaceType::Cat,
            3 => ERaceType::Dog,
            4 => ERaceType::Bird,
            5 => ERaceType::Bug,
            6 => ERaceType::Fish,
            7 => ERaceType::Dragon,
            8 => ERaceType::Snake,
            9 => ERaceType::Hoofed,
            10 => ERaceType::Lizard,
            11 => ERaceType::Rodents,
            12 => ERaceType::Molluscs,
            13 => ERaceType::Furry,
            14 => ERaceType::Mod1,
            15 => ERaceType::Mod2,
            16 => ERaceType::Mod3,
            17 => ERaceType::Mod4,
            18 => ERaceType::Mod5,
            19 => ERaceType::Mod6,
            20 => ERaceType::Mod7,
            21 => ERaceType::Mod8,
            _ => panic!("Invalid value for ERaceType:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ERare {
    None = 0,
    Common = 1,
    Rare = 2,
    Legend = 3,
    Epic = 4,
    Mythic = 5,
}

impl From<i32> for ERare {
    fn from(value: i32) -> Self {
        match value {
            0 => ERare::None,
            1 => ERare::Common,
            2 => ERare::Rare,
            3 => ERare::Legend,
            4 => ERare::Epic,
            5 => ERare::Mythic,
            _ => panic!("Invalid value for ERare:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum Etip {
    None = 0,
    Sum = 1,
    Before = 2,
    Prob = 3,
    SumEnd = 4,
    Near = 5,
}

impl From<i32> for Etip {
    fn from(value: i32) -> Self {
        match value {
            0 => Etip::None,
            1 => Etip::Sum,
            2 => Etip::Before,
            3 => Etip::Prob,
            4 => Etip::SumEnd,
            5 => Etip::Near,
            _ => panic!("Invalid value for Etip:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct Element {
    /// 这是id
    pub Id: i32,
    /// 是否锁定
    pub Lock: i32,
    /// 是否启用
    pub Enable: i32,
    /// 专属角色
    pub Role: i32,
    pub name_id: i32,
    pub desc_id: i32,
    /// 特殊描述类型
    pub desctip: Vec<crate::element::Etip>,
    /// 描述使用属性
    pub DescAttribute: Vec<i32>,
    /// 全身像
    pub Icon: String,
    /// 稀有度
    pub Rare: i32,
    /// 种族
    pub RaceType: crate::element::ERaceType,
    /// 其他种族
    pub OtherRace: crate::element::ERaceType,
    /// 初始属性
    pub Attribute: Vec<crate::ElementAttribute>,
    /// 触发器
    pub TriggerType: i32,
    /// 触发参数
    pub TriggerParam: Vec<i32>,
    /// 事件响应语言ID
    pub EventTip: i32,
    /// 触发行为
    pub TriggerAction: i32,
    /// 触发行为时数值
    pub TriggerValue: Vec<crate::ElementTriggerValue>,
    /// 其他参数
    pub OtherValue: Vec<i32>,
    /// 攻击音效
    pub AttackSound: i32,
    /// 选中音效
    pub SelectSound: i32,
    /// 攻击特效
    pub AttackParticle: i32,
}

impl Element{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Element, LubanError> {
        let Id = buf.read_int();
        let Lock = buf.read_int();
        let Enable = buf.read_int();
        let Role = buf.read_int();
        let name_id = buf.read_int();
        let desc_id = buf.read_int();
        let desctip = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int().into()); } _e0 };
        let DescAttribute = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let Icon = buf.read_string();
        let Rare = buf.read_int();
        let RaceType = buf.read_int().into();
        let OtherRace = buf.read_int().into();
        let Attribute = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ElementAttribute::new(&mut buf)?); } _e0 };
        let TriggerType = buf.read_int();
        let TriggerParam = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let EventTip = buf.read_int();
        let TriggerAction = buf.read_int();
        let TriggerValue = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::ElementTriggerValue::new(&mut buf)?); } _e0 };
        let OtherValue = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let AttackSound = buf.read_int();
        let SelectSound = buf.read_int();
        let AttackParticle = buf.read_int();
        
        Ok(Element { Id, Lock, Enable, Role, name_id, desc_id, desctip, DescAttribute, Icon, Rare, RaceType, OtherRace, Attribute, TriggerType, TriggerParam, EventTip, TriggerAction, TriggerValue, OtherValue, AttackSound, SelectSound, AttackParticle, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.Attribute.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.TriggerValue.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -1395381782;
}


#[derive(Debug)]
pub struct tbelement {
    pub data_list: Vec<std::sync::Arc<crate::element::Element>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::element::Element>>,
}

impl tbelement {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<tbelement>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::element::Element>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::element::Element>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::element::Element::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.Id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(tbelement { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::element::Element>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::element::Element as *mut crate::element::Element); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for tbelement {
    type Output = std::sync::Arc<crate::element::Element>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


