
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

#![allow(warnings)]
#![allow(clippy::all)]
pub mod prelude {
    pub use crate::*;
    pub use crate::element::*;
    pub use crate::localization::*;
    pub use crate::raceattribute::*;
    pub use crate::enemy::*;
    pub use crate::relics::*;
}

#[derive(Debug)]
pub enum LubanError {
    Loader(String),
    Table(String),
    Bean(String),
    Polymorphic(String),
    Unknown(String),
}

impl std::fmt::Display for LubanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            LubanError::Loader(msg) |
            LubanError::Table(msg) |
            LubanError::Bean(msg) |
            LubanError::Polymorphic(msg) |
            LubanError::Unknown(msg) => msg,
        })
    }
}

pub struct Tables{
    pub tbelement: std::sync::Arc<crate::element::tbelement>,
    pub tblocalization: std::sync::Arc<crate::localization::tblocalization>,
    pub tbraceattribute: std::sync::Arc<crate::raceattribute::tbraceattribute>,
    pub tbenemy: std::sync::Arc<crate::enemy::tbenemy>,
    pub tbrelics: std::sync::Arc<crate::relics::tbrelics>,
}

impl Tables {
    pub fn new<T: Fn(&str) -> Result<ByteBuf, LubanError>>(loader: T) -> Result<Tables, LubanError> {
        let mut tables =Tables{
            tbelement: crate::element::tbelement::new(loader("element_tbelement")?)?,
            tblocalization: crate::localization::tblocalization::new(loader("localization_tblocalization")?)?,
            tbraceattribute: crate::raceattribute::tbraceattribute::new(loader("raceattribute_tbraceattribute")?)?,
            tbenemy: crate::enemy::tbenemy::new(loader("enemy_tbenemy")?)?,
            tbrelics: crate::relics::tbrelics::new(loader("relics_tbrelics")?)?,
        };
        unsafe { tables.resolve_ref(); }
        Ok(tables)
    }

    unsafe fn resolve_ref(&mut self) {
        let mut b = Box::from_raw(self.tbelement.as_ref() as *const crate::element::tbelement as *mut crate::element::tbelement); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.tblocalization.as_ref() as *const crate::localization::tblocalization as *mut crate::localization::tblocalization); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.tbraceattribute.as_ref() as *const crate::raceattribute::tbraceattribute as *mut crate::raceattribute::tbraceattribute); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.tbenemy.as_ref() as *const crate::enemy::tbenemy as *mut crate::enemy::tbenemy); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.tbrelics.as_ref() as *const crate::relics::tbrelics as *mut crate::relics::tbrelics); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
    }
}
pub mod element;
pub mod localization;
pub mod raceattribute;
pub mod enemy;
pub mod relics;

use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum AudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}

impl From<i32> for AudioType {
    fn from(value: i32) -> Self {
        match value {
            0 => AudioType::UNKNOWN,
            1 => AudioType::ACC,
            2 => AudioType::AIFF,
            _ => panic!("Invalid value for AudioType:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct ElementAttribute {
    pub ID: i32,
    pub Value: i32,
}

impl ElementAttribute{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ElementAttribute, LubanError> {
        let ID = buf.read_int();
        let Value = buf.read_int();
        
        Ok(ElementAttribute { ID, Value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1945629920;
}

#[derive(Debug)]
pub struct ElementTriggerValue {
    pub Value: Vec<i32>,
}

impl ElementTriggerValue{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ElementTriggerValue, LubanError> {
        let Value = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(ElementTriggerValue { Value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -293683307;
}

#[derive(Debug)]
pub struct UnlockCondition {
    pub UnlockType: i32,
    pub Condition: i32,
}

impl UnlockCondition{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UnlockCondition, LubanError> {
        let UnlockType = buf.read_int();
        let Condition = buf.read_int();
        
        Ok(UnlockCondition { UnlockType, Condition, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -877440489;
}

#[derive(Debug)]
pub struct vec2 {
    pub x: f32,
    pub y: f32,
}

impl vec2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec2, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        
        Ok(vec2 { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615518;
}

#[derive(Debug)]
pub struct vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vec3{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec3, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();
        
        Ok(vec3 { x, y, z, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615519;
}

#[derive(Debug)]
pub struct vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vec4{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec4, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();
        let w = buf.read_float();
        
        Ok(vec4 { x, y, z, w, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615520;
}


