
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug)]
pub struct Relics {
    /// 这是id
    pub Id: i32,
    /// 是否启用
    pub Enable: i32,
    /// 是否锁定
    pub Lock: i32,
    /// 专属角色
    pub role: i32,
    /// 教程出现
    pub tutorial: i32,
    /// 图标
    pub Icon: String,
    /// 小图标
    pub SmallIcon: String,
    /// 名称ID
    pub NameID: i32,
    /// 遗物描述ID
    pub DescID: i32,
    /// 剧情描述ID
    pub OtherDescID: i32,
    /// 特殊描述类型
    pub DescTip: Vec<crate::element::Etip>,
    /// 稀有度
    pub Rare: i32,
    /// 被动属性
    pub Passive: Vec<i32>,
    /// 触发条件
    pub TriggerType: i32,
    /// 触发条件
    pub TriggerParam: Vec<i32>,
    /// 事件响应语言ID
    pub EventTip: i32,
    /// 触发行为
    pub TriggerAction: i32,
    /// 加成数值
    pub TriggerValue: Vec<i32>,
    /// 其他参数
    pub OtherValue: Vec<i32>,
}

impl Relics{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Relics, LubanError> {
        let Id = buf.read_int();
        let Enable = buf.read_int();
        let Lock = buf.read_int();
        let role = buf.read_int();
        let tutorial = buf.read_int();
        let Icon = buf.read_string();
        let SmallIcon = buf.read_string();
        let NameID = buf.read_int();
        let DescID = buf.read_int();
        let OtherDescID = buf.read_int();
        let DescTip = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int().into()); } _e0 };
        let Rare = buf.read_int();
        let Passive = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let TriggerType = buf.read_int();
        let TriggerParam = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let EventTip = buf.read_int();
        let TriggerAction = buf.read_int();
        let TriggerValue = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let OtherValue = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(Relics { Id, Enable, Lock, role, tutorial, Icon, SmallIcon, NameID, DescID, OtherDescID, DescTip, Rare, Passive, TriggerType, TriggerParam, EventTip, TriggerAction, TriggerValue, OtherValue, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1437992398;
}


#[derive(Debug)]
pub struct tbrelics {
    pub data_list: Vec<std::sync::Arc<crate::relics::Relics>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::relics::Relics>>,
}

impl tbrelics {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<tbrelics>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::relics::Relics>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::relics::Relics>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::relics::Relics::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.Id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(tbrelics { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::relics::Relics>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::relics::Relics as *mut crate::relics::Relics); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for tbrelics {
    type Output = std::sync::Arc<crate::relics::Relics>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


