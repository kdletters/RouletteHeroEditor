
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug)]
pub struct Enemy {
    /// 这是id
    pub Id: i32,
    /// 图标
    pub Icon: String,
    /// 多语言ID
    pub NameID: i32,
    /// 描述多语言
    pub DescID: i32,
    /// 地圖
    pub Map: i32,
    /// 关卡
    pub Level: i32,
    /// BOSS類型
    pub BOSS: i32,
    /// 血量
    pub Hp: i32,
    /// 攻击力
    pub Attack: i32,
    /// 升级攻击力
    pub UpgradeAttack: i32,
    /// 血量
    pub EndlessHp: i32,
    /// 攻击力
    pub EndlessAttack: i32,
    /// 升级攻击力
    pub EndlessUpgrade: i32,
    /// 奖励金币
    pub Gold: i32,
    /// 最大奖励金币
    pub GoldMax: i32,
    /// 攻击音效
    pub AttackSound: i32,
    /// 出场音效
    pub ShowSound: i32,
}

impl Enemy{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Enemy, LubanError> {
        let Id = buf.read_int();
        let Icon = buf.read_string();
        let NameID = buf.read_int();
        let DescID = buf.read_int();
        let Map = buf.read_int();
        let Level = buf.read_int();
        let BOSS = buf.read_int();
        let Hp = buf.read_int();
        let Attack = buf.read_int();
        let UpgradeAttack = buf.read_int();
        let EndlessHp = buf.read_int();
        let EndlessAttack = buf.read_int();
        let EndlessUpgrade = buf.read_int();
        let Gold = buf.read_int();
        let GoldMax = buf.read_int();
        let AttackSound = buf.read_int();
        let ShowSound = buf.read_int();
        
        Ok(Enemy { Id, Icon, NameID, DescID, Map, Level, BOSS, Hp, Attack, UpgradeAttack, EndlessHp, EndlessAttack, EndlessUpgrade, Gold, GoldMax, AttackSound, ShowSound, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1023814270;
}


#[derive(Debug)]
pub struct tbenemy {
    pub data_list: Vec<std::sync::Arc<crate::enemy::Enemy>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::enemy::Enemy>>,
}

impl tbenemy {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<tbenemy>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::enemy::Enemy>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::enemy::Enemy>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::enemy::Enemy::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.Id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(tbenemy { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::enemy::Enemy>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::enemy::Enemy as *mut crate::enemy::Enemy); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for tbenemy {
    type Output = std::sync::Arc<crate::enemy::Enemy>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


